\chapter{Diseño del sistema}

\section{Consideraciones generales sobre el diseño}

\subsection{Visión por componentes}

Al momento de comenzar a atacar el diseño, nos propusimos identificar los distintos
componentes lógicos del sistema, con el objeto de examinarlos por separado tratarlos
de forma análoga. Esta idea está en consonancia con el buen diseño puesto que:
\begin{itemize}
\item \textbf{Aumenta la cohesión}: Las partes que atacan un mismo problema están dentro
      de un mismo componente y cooperan para un mismo fin estrechamente.
\item \textbf{Disminuye el acoplamiento}: Al hacer que los componentes se comuniquen entre
      sí lo menos posible, se disminuyen las dependencias trans-componente lo cual hace
      que las extensiones y modificaciones al sistema tengan un carácter más local.
\end{itemize}

Distinguimos así los siguientes componentes, con las interacciones que aparecen en
el diagrama \ref{diag_componentes}.

\begin{figure}
\centering
\includegraphics[height=10cm]{./figuras/divisionModelo.png}
\caption{Diagrama de componentes lógicos}
\label{diag_componentes}
\end{figure}
%FIXME: hay que hacer de vuelta este dibujo, en parte porque es feo
%       pero más que nada porque tiene muy pocos pixeles y se ve mal

\begin{itemize}
\item \textbf{Pedidos fuera de la cocina}: Este componente agrupa las funcionalidades 
      del ingreso, despacho, consulta de estado y otros aspectos que involucren a las 
      partes del ciclo de vida que no ocurran en el ámbito de la cocina.
\item \textbf{Creación de pedidos}: Aquí se agrupan aquellas funcionalidades que hacen 
      posible que se creen e ingresen al sistema nuevos pedidos. Podría considerarse parte 
      del componente anterior, pero sin embargo la creación tiene una lógica bastante 
      compleja de estimación de tiempos y chequeo de stock que ameritan su consideración
      como un componente separado.
\item \textbf{Gestión de clientes}: Este componente permite realizar las validaciones de clientes así 
      como también las altas, bajas y modificaciones de clientes.
\item \textbf{Cocina}: Aquí se engloban las funciones que permiten guiar la preparación 
      y cocción de un pedido.
\item \textbf{Gestión de stock y productos}: En este componente se engloban las funcionalidades
      referidas con el stock, los productos y sus precios.
\end{itemize}

La idea de esta componentización es reducir al mínimo los intercambios intercomponente,
para así tener la mayor parte de las dependencias dentro de los bloques y no entre ellos,
y minimizando así el acoplamiento.

\subsubsection{Limitaciones de esta visión}

En algunos casos, existen operaciones que afectan al grueso del sistema y por lo tanto
no pueden separarse en componentes sin arruinar la simplicidad inherente a la
separación. Es el caso, en particular, del método de cancelación de pedidos. Esta
cuestión recibe un tratamiento particular por fuera de los componentes. A su vez,
otra cuestión que podría verse limitada por esta visión es la predicción de tiempos
de cocción y preparación de pedidos: para realizar una estimación precisa, será necesario
conocer detalles propios de cada política de horno o de cola de ingreso de pedidos, lo
cual es inherentemente acoplado.

\subsection{Visión según MVC}

El patrón \textbf{MVC} (\textit{Model/View/Controller}) dictamina que deben considerarse
por separado los datos, la lógica del sistema y la presentación de información a los
usuarios. El actual documento subespecifica voluntariamente el diseño de las vistas,
centrándose en el diseño del sistema subyacente. Por lo tanto, es fácil reconocer dos
tipos de clases en el diseño que propondremos:
\begin{itemize}
\item \textbf{Modelos de datos}, correspondientes a las estructuras de datos del sistema
      (por ejemplo las clases Producto, Pedido, Insumo y Cliente). Esto se corresponde con
      la letra \textbf{M} en MVC.
\item \textbf{Controladores}, correspondientes a la lógica del sistema. Estas clases tienen
      generalmente una única instancia y son responsables de los cambios de estado del sistema
      (por ejemplo las clases ControladorStock, CoordinadorDePedidos, DespachadorDePreparacion
      son clases de este tipo). Esto se corresponde con la letra \textbf{C} en MVC.
\end{itemize}

Si bien no consideramos en detalle el diseño de las vistas, consideramos que no es
necesario hacerlo dado que en general su implementación es sencilla. Por otra parte, si
tenemos en cuenta a la hora de diseñar el sistema la forma en que se interactuará con la
interfaz de usuario. Por esta razón, se dotó al sistema de una interfaz gruesa a través
de quien será posible unificar las comunicaciones que se llevan a cabo entre la GUI y el
\textit{backend}. Si bien es factible que para lograr una mayor integración entre el
sistema y la interfaz sea posible saltear esta capa de abstracción, la idea es minimizar
la ocurrencia de estos saltos. Esta decisión está en consonancia con DIP y se ilustra
en el patrón \textit{Façade}.

A su vez, consideramos que la GUI podrá tener una mínima dosis de inteligencia y
no ser controlada totalmente por el sistema que diseñamos. Si bien uno podría, con el
fin de minimizar el acoplamiento, especificar un formato de intercambio de datos entre
la GUI y el \textit{backend} para evitar las interdependencias, consideramos que eso
sería excesivo en este caso y complicaría de sobremanera el diseño. Por lo tanto, 
en nuestra concepción la intefaz gráfica puede operar con objetos del sistema tales
como Pedido o Producto, pero solo como un observador, lo cual le permite informar
al usuario sobre el estado del sistema. Si bien esto parece introducir un acoplamiento
importante, el uso de interfaces como dicta ISP en esta situación agrega mucho
código y ninguna flexibilidad (ya que, si se deseara modificar el comportamiento
de los objetos, solo habría que mantener la interfaz actual, pero no la implementación).
La encapsulación propia de los objetos nos ayuda entonces a mantener el sistema simple
y flexible.

\subsection{Particularidades de diseño}

\subsubsection{Singleton}

El patrón \textit{Singleton} es sin duda uno de los más controversiales entre los
listados en el libro de GoF. Si bien ofrece una solución transparente a la problemática
de instancias únicas (que sería el caso, en nuestro sistema, de las clases controladoras),
introduce acoplamiento puesto que hace que los usuarios del \textit{Singleton} deban
conocer a la clase y construir sus instancias ellos mismos. Esto, a su vez, hace que el
código sea más difícil de testear ya que este acoplamiento impide el uso de \textit{mockups}.

Para este diseño tomamos la decisión de no usar \textit{Singleton} y en su lugar construir
una única vez todos los controladores en la inicialización del sistema, y luego pasarle a sus
usuarios las referencias necesarias para que se sirvan de ellos.

\subsubsection{Controladores para ABM}
\label{metodosEstaticos}
Para cada objeto que representa un modelo de datos, son necesarios métodos para la 
funcionalidad de ABM. Si bien es posible implementar un controlador \textit{ad hoc} a
cada clase donde se permitan obtener todas las instancias de dicha clase, y crear,
modificar o destruir algunas de ellas, optamos por utilizar métodos estáticos de la
clase para obtener todas las instancias (\verb0allInstances()0) y métodos del
propio objeto para la funcionalidad de ABM. Esto evita la proliferación de controladores
que no tienen funcionalidad especial y mantiene más corto el código. Esta técnica
es muy popular en varios \textit{Object Relational Mappers}.

\subsubsection{Observers}

En muchos casos es necesario que el sistema sea capaz de transmitir a la interfaz de usuario
la ocurrencia de un evento para que dicha interfaz pueda tomar acciones o notificar al usuario
de dichos eventos. Para esto, nos servimos del patrón \textit{Observer} que permite
la comunicación bidireccional entre dos objetos pero mantiene un acoplamiento unidireccional.
Esto es favorable a DIP y reduce el acoplamiento del sistema. Por esta razón, a lo largo
del informe cuando nos referimos a la notificación de eventos, se trata siempre de objetos
de este tipo.

\subsection{Flexibilidad y Rigidez}

A lo largo del diseño se tuvieron que tomar decisiones sobre qué aspectos serían
más fácilmente modificables y qué aspectos estarían más incrustados en el diseño
del sistema. Con este fin, intentamos inferir qué cambios tenían una mayor posibilidad
de ocurrir y necesitar ser implementados. En función de esto, le dimos prioridad a:
\begin{itemize}
\item Permitir agregar nuevas políticas de cola de horno
\item Permitir agregar nuevas políticas de cola de ingreso de pedidos
\item Permitir agregar nuevos algoritmos de estimación de tiempo
\item Permitir agregar nuevas operatorias de cocina
\item Permitir agregar nuevos cocineros (con aptitudes distintas a los actuales)
\item Permitir la venta de nuevos tipos de producto
\item Permitir procesos de cocción diferentes para los nuevos productos
\end{itemize}

La mayoría de estas posibilidades se deducen del conocido principio de diseño de UNIX:
``\textit{Separate policy from mechanism}'', qué indica que es conveniente distinguir
las decisiones tomadas por el sistema de las herramientas que se utilizan para tomarlas
y llevarlas a cabo. En el diseño orientado a objetos, esto redunda en muchos casos
en el uso de patrones \textit{Strategy} o \textit{Visitor}.

\section{Diagrama de clases}
\begin{landscape}
\begin{figure}[H]
\centering
\includegraphics[height=18cm]{./figuras/clases.png}
\end{figure}
\end{landscape}
