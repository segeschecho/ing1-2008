\chapter{Clases}
\section{Modelado de clases}
Nuestra primer idea al modelar la solución, fue identificar los diversos componentes logicos presentes en el sistema. De esta manera pudimos identificar la existencia de grupos de funcionalidades que se podían agrupar. Consideramos la existencia de los siguientes componentes:

\begin{figure}[H]
\centering
\includegraphics[height=10cm]{./figuras/divisionModelo.png}
\caption{Esquema de componentes lógicos}
\end{figure}
%FIXME: el dibujo mepa q esta mal
\begin{itemize}
\item Pedidos fuera de la cocina: Este componente agrupa las funcionalidades del ingreso, despacho, consulta de estado y otros aspectos que involucren a las partes del ciclo de vida que no ocurran en el ambito de la cocina.
\item Creación de pedidos: Aquí se agrupan aquellas funcionalidades que hacen posible que se creen e ingresen al sistema nuevos pedidos. Podría considerarse parte de Pedidos fuera de la cocina, pero sin embargo la creación tiene una logica bastante compleja de estimación de tiempos, chequeo de stock, entre otras cosas que nos llevaron a considerarlo como un componente separado.
\item Gestión de clientes: Este componente permite realizar las validaciones de clientes asi como también las altas, bajas y modificaciones de clientes
\item Cocina: Aqui se engloban las funciones que permiten guiar la preparación y cocción de un pedido.
\item Gestión de stock y productos: En este componente se engloba el ABM de stock y el ABM de productos
\end{itemize}

Esta división sirve para guía pero no es estrictamente asi, ya que por ejemplo la cancelación es un evento que toca tanto a la cocina como a los pedidos fuera de esta, por otro lado el Pedido como tipo de datos es utilizado por todos los componentes en mayor o menor medida. No obstante creemos que esta división en componentes sirve para mostrar el enfoque que se le dio al diseño

\section{Pedidos fuera de la cocina}
Como dijimos este componente tiene por responsabilidad el manejo de la vida de los pedidos que estan fuera de la cocina (por cocina entendemos no solo al horno, sino también a la preparación de los pedidos).

Nuestra idea fue tener un coordinadorDePedidos que siga el patron Façade, de modo que muestre a la interfaz grafica una intrefaz \textit{``gruesa''} con las funciones que se realizan dentro del componente. Esta clase no va a tener gran inteligencia, sino que se limitara a propagar la llamada originada por la interfaz grafica a la clase responsable de manejar esa llamada. Así, por ejemplo para ver el estado de un pedido o ingrear un nuevo pedido se deberá pasar por esta clase.
La idea de esta clase es desacoplar la interfaz grafica de las clases que manejan a los pedidos fuera de la cocina. Si bien esta clase para tener baja cohesión, al mirarla de cerca vemos que lo único que hace es derivar las llamadas. De este modo si bien a trazo grueso parece tener una interfaz con poca cohesión, esta nos permite lograr un menor grado de acoplamiento entre la interfaz y el sistema en si. Por esta razón decidimos pese al aparente conflicto con la cohesión, decidimos mantener esta clase.
Ademas el coordinadorDePedidos se comunica con el componente encargado de crearPedidos, haciendo de puente entre ambos componentes.
Cuando se realiza un pedido de ingreso, el coordinador se encarga de pedir que se genere el pedido, y en caso de que se pueda crear, lo deriva al controladorDePreIngreso, cuya función es determinar si el pedido debe ir a la cola de listos, porque no hay nada que preparar, ni cocinar, o lo tiene que mandar al controlador de ingreso, porque hay algo que cocinar o preparar. Este comportamiento se hizo con la intención de permitir en un futuro incorporar otros productos ademas de pizzas o empanadas. Por ejemplo, podrian venderse ensaladas, las cuales no requieren de cocción, pero si de preparación. Por eso decidimos que un producto tuviera atributos de cocinable y preparable.

El controladorDeIngreso se encarga de mantener la cola de ingreso, asi como de suministrar los pedidos al CoordinadorDeCocina, para que este los distribuya al preparador o al coordinador de horno.
El coordinadorDeIngreso puede recibir recibir una solicitud de un pedido de cierto tipo por parte del CoordinadorDeCocina, por ejemplo puede recibir una solicitud del proximo pedido que contenga algun producto del tipo empanada. 
Por otro lado, cada vez que ingresa un nuevo pedido, el controladorDeIngreso pregunta al CoordinadorDeCocina si puede recibir dicho pedido. Esta funcionalidad sirve para aquellos casos en los que por ejemplo no hay ningun pedido ingresado con empanadas y el maestro empanadero esta ocioso. Si llega un nuevo pedido con empanadas, el maestro debe ser notificado, por esta razon el ControladorDeIngreso pregunta si debe encolar el pedido o hay alguien que lo vaya a preparar.
%FIXME: la parte de preguntar es propia del standard, es decir del concreto

Otra clase de este componente, es el ControladorDeListos, este controlador va a recibir los pedido listos y va a encargarse en el momento del despacho de decidir que hacer con el pedido. Por ejemplo si es un pedido con delivery hay que marcar que salio con el delivery, y si era local hay que marcarlo como finalizado.

La clase controladorDeEntragas contiene a todos los pedidos cuya entrega esta pendiente, y se encargan de finalizar el pedido cuando se notifica la entrega.

Por ultimo el controladorPedidosMesa monitorea los pedidos entregados a una cierta mesa, permitiendo que al cerrar la mesa se fijen sus formas de pago.

La clase controladorDeIngreso es abstracta porque consideramos que la estrategia con la que se maneja la cola de ingreso podria cambiar, de esta manera la versión propuesta por nosotros en la etapa de especificación es implementada por controladorDeIngresoStandard. Utilzar una clase abstracta nos permite lograr flexibilidad si se quiere cambiar de politica de manejo de esta cola, por ejemplo usando un manejo del tipo mas corto primero.


\textcolor{Red}{TODO: interacciones de estas clases con la GUI}

\textcolor{Red}{TODO: explicacion de metodos importantes}

\subsection{Modelado de escenarios}
%FIXME: en el ingreso se da a la gui la responsabilidad de mostrar los datos del pedido, tiempo estimado y precio, no se si eso esta bien
\subsubsection{Ingreso de un pedido de solo bebidas}
A continuación intentaremos mostrar las interacciones existentes en este componente con el fin de modelar su comportamiento.
Como primer escenario veamos que ocurre cuando ingresa un pedido de solo bebidas Telefonico. En este caso el pedido será creado por el generador de pedidos, sin embargo las interacciones propias de la creación no se detallaran en este escenario. Una vez que el pedido es creado, pasa al controlador de pre ingreso que lo examina para decidir si debe ir a la cocina o considerarse un pedido listo. En este caso, como solo hay bebidas, el pedido queda listo. El controlador de listos agrega el pedido a su lista de pedidos, se hace responsable del mismo y cambia su estado. Ademas el controlador de listos notifica a la gui para que recargue la lista de pedidos en estado listo. %TODO: lograr consenso de como hacer eso

\begin{figure}
\centering
\includegraphics[height=9cm]{./figuras/remotoBebidas.png}
\caption{Ingreso de un pedido remoto de solo bebidas}
\end{figure}

\subsubsection{Ingreso de un pedido con comidas}
De forma analoga al escenario anterior, supongamos que se va a ingresar un pedido, pero en este caso, el pedido si tenía comidas, por lo que el controlador de pre ingresos se lo va a mandar al de ingresos. Este intenta pasarlo a la cocina para ver si esta puede hacerse cargo del pedido. Esto es asi porque en la especificación se pide que si entra un pedido y el maestro estaba ocioso, se le notifique que prepare el pedido ingresado. Como conocer si los maestros estan preparando algo o no no es asunto de este controlador lo que decidimos es que lo pase hacia la cocina y espere respuesta de esta. Modelaremos los dos escenarios, primero el caso en el que la cocina le dice que no puede hacerse cargo y en segundo lugar el caso en el que la cocina si acepta el pedido. %TODO: problema se esta fijando un protocolo, pero las clases que participan en el son abstractas, esta bien?

En el primer caso, el controlador de ingresos se hace cargo del pedido, cambiando su estado, marcando el pedido como ingresado y agregandolo a la cola.

\begin{figure}
\centering
\includegraphics[height=7cm]{./figuras/remotoComidas.png}
\caption{Ingreso de un pedido remoto con comida que queda encolado para su ingreso}
\end{figure}
%FIXME: el controlador de ingreso del diagrama deberia ser el abstracto o el concreto? si usamos el abstracto el metodo preparar tiene que quedar fijo

En el segundo caso, como se va a hacer cargo la cocina, el controlador de ingreso no debe hacer nada cuando se regresa la llamada.

\begin{figure}
\centering
\includegraphics[height=5cm]{./figuras/remotoComidasquedapreparando.png}
\caption{Ingreso de un pedido remoto con comida que pasa a estar preparando}
\end{figure}

\subsubsection{Despacho de un pedido}

\subsubsection{Pedido de proximo pedido a preparar}
%TODO: decidir aridad de esta función
%TODO: mostrar pseudocodigo

\subsubsection{Notificación de entrega}

\subsubsection{Cerrado de mesa}

\subsubsection{Consulta de estado}

\section{Creación y registro de pedidos}
En este componente se agrupan las clases que entran en juego al momento de crear un nuevo pedido.

La clase GeneradorDePedidos sirve de punto de entrada a este componente. El mismo posee el método generarPedido, que es invocado por el Coordinador de pedidos, a fin de que se ingrese al sistema un nuevo pedido.

El Generador se encarga de llamar al controladorDeStock para que verifique que el stock existente sea capaz de satisfacer al pedido. Ademas el generador realiza el decremento del stock, y se encarga de realizar el callback a la gui en caso de que un insumo quede por debajo de su stock critico. %TODO: callback como?
El controlador de stock no es una clase abstracta porque creemos que no es probable que cambie su funcionamiento, el cual es bastante concreo, es decir revisar los elementos necesarios para armar los productos propios de un pedido y decrementar el stock. 

Luego de que se regisró el decremento de stock, el Generador se encarga de llamar al EstimadorDeTiempos. Esta clase es abstracta, ya que pensamos que como la pizzeria desea ir refinando estas estimaciones, es probable que la forma de estimar se modifique de forma periodica. Por lo tanto, decidimos aplicar el \textit{Strategy pattern} a fin de poder lograr varias estrategias de estimación. La Estimación desarrollada en \ref{modifEstim} es implementada por la clase EstimadorBasico.

\textcolor{Red}{TODO: interacciones de estas clases con la GUI}

\textcolor{Red}{TODO: explicacion de metodos importantes}
\subsection{Modelado de escenarios}
\textcolor{Red}{TODO: escenarios que muestren el comportamiento de estas clases en los fenomenos pedidos en el enunciado}

\textcolor{Red}{TODO: pseudocodigos que muestren algoritmos como por ej estimacion de tiempos}

\section{Gestión de clientes}
Este componente es el responsable de validar clientes, para realizar las operaciones que requieren que se valide al usuario antes de proceder, como por ejemplo, ingresar un nuevo pedido telefonico. Por otro lado, este componente permite realizar el registro de nuevos usuarios en el sistema.

Basicamente son dos clases las relacionadas con este componente, la clase Cliente que modela la información necesaria de cada cliente registrado, asi como también permite crear nuevos clientes. 

Luego tenemos la clase ControladorCliente que se encarga de interactuar con la gui, validando los clientes segun distintos atributos.

\textcolor{Red}{TODO: interacciones de estas clases con la GUI}

\textcolor{Red}{TODO: explicacion de metodos importantes}
\subsection{Modelado de escenarios}
\textcolor{Red}{TODO: escenarios que muestren el comportamiento de estas clases en los fenomenos pedidos en el enunciado}

\section{Cocina}
La cocina es el componente de mayor complejidad del sistema. Al igual que en el manejo de pedidos fuera de la cocina, tenemos una clase que sirve de punto de entrada y de controlador de flujo dentro de la cocina, derivando a los pedidos al despachador o controlador correspondiente. Esta clase es la que tiene contacto con el controlador de ingresos, de modo que todo pedido que quiere entrar en la cocina pasa por este coordinador. Cuando recibe un pedido, o pide un pedido, esta clase es la que decide quien debe hacerse cargo de recibir al pedido. Si consideramos el funcionamiento actual de la pizzería, donde los pedidos que llegan a la cocina son preparables y cocinables, al ingresar un pedido a la cocina, el coordinador lo va a enviar al despachador de preparacion y luego cuando este lo termine se lo enviará al despachador de cocción. 

El despachador de preparación es una clase abstracta que tiene por responsabilidad mantener la cola de pedidos que deben ser preparados, conocer que subpedidos se prepararon y notifiar cuando el pedido ya fue preparado. Decidimos que sea abstracta porque es factible considerar que hay diferentes formas de manejar que pedido de los que estan esperando debe preparse a continuación. Ademas, la implementación de estas funcionalidades va a estar acoplada fuertemente con los tipos de productos existentes y el manejo que se le de a los mismos. Por ejemplo, es razonable que como la pizzería solo maneja pizzas y empanadas, las cuales son preparadas por un unico maestro, el despachador divida a un pedido en solo estas dos partes, sin embargo si en el futuro se agregan ensaladas, el pedido tendria que ser dividio de otra manera. Entonces a fin de dar mayor extensibilidad decidimos hacer que esta clase sea abstracta. En particular el despachador que se comporta como lo mostrado en la especificación es implementado por DespachadorDePreparaciónEstandard. Esta clase que hereda del despachador de preparación, sabe distribuir pizzas y empanadas a sendos preparadores.

Preparador es una interfaz que tiene como metodo principal preparar. La idea es que este metodo sea el que hable con la gui para mostrar que se debe preparar. Decidimos hacer una interfaz para esto, porque si bien en este momento se muestra todo el contenido del pedido (o subpedido a preparar), esta estraetgia podría cambiar, si por ejemplo se desea tener un contro de cada producto del pedido. Entonces nuestro preparador especializado que implementa esta interfaz funciona como lo planteamos en la especificación.

La clase despachadorDeHorno es la responsable del manejo de las colas de ingreso a los hornos, aplicando la politica correspondiente. En principio habiamos considerado que era conveniente separar la aplicación de la politica del mantenimiento de las colas, sin embargo dado que la aplicación de la politica requiere de un acceso completo a las colas, nos pareció acertado acoplar ambas funcionalidades. La clase es abstracta, siguiendo el \textit{strategy pattern} a fin de permitir que se implementen diferentes politicas de manera flexible.

La clase ControladorHorno es una abstraccion de los modulos del horno, esta clase permite poner algo en un modulo, asi como también sacar algo de un modulo, o conocer que es lo que hay en cada modulo. Cada controladorHorno posee ademas un fraccionador que sabe fraccionar un pedido en partes que entran en un modulo, contando para eso con un diccionario que dado un tipo de pedido pueda decidir cuantos productos de ese tipo entran en cada modulo.

\textcolor{Red}{TODO: interacciones de estas clases con la GUI}

\textcolor{Red}{TODO: explicacion de metodos importantes}
\subsection{Modelado de escenarios}
\textcolor{Red}{TODO: escenarios que muestren el comportamiento de estas clases en los fenomenos pedidos en el enunciado}

\textcolor{Red}{TODO: pseudocodigos que muestren algoritmos como por ej seleccion de proximo pedido a cocinar}

\section{Gestión de stock y productos}
Como dijimos anteriormente, este componente es el que brinda las funcionalidades de ABM de stock y productos, asi como también permite acceder a la información sobre los diversos insumos y productos.

Sus clases principales son basicamente la clase Insumo y la clase Producto. 

Para realizar los ABM se decidio que la GUI utilice directamente los metodos de las clases antes nombradas, de modo que para crear un Insumo, lo que hace es invocar el new de Insumo, consideramos que esto si bien acopla un poco la GUI al sistema, creemos que no era necesario hacer un \textit{proxy} entre la GUI y estas clases, ya que la interacción era simple.

Otra clase propia de este componente es el Tipo de producto, que permite identificar por ejemplo a las pizzas, a las empanadas, asi como también, decir si un tipo de producto es cocinable, y$/$o preparable.
\textcolor{Red}{TODO: interacciones de estas clases con la GUI}


\subsection{Modelado de escenarios}
\textcolor{Red}{TODO: escenarios que muestren el comportamiento de estas clases en los fenomenos pedidos en el enunciado}

\textcolor{Red}{TODO: explicacion de metodos importantes}

\section{Cancelación}
La cancelación es un evento que involucra tanto al componente cocina como al componente de pedidos fuera de la cocina, por lo que podria incluso considerarse un componente separado. 

Mediante la interfaz grafica se selecciona un pedido y se invoca el metodo cancelar que posee el mismo, este metodo lo que hace es invocar el cancelar del responsable de cancelacion del pedido. Decidimos hacerlo de esta manera, en primer lugar, porque la cancelación es un proceso que puede ser complejo, ya que por ejemplo, al cancelar un pedido que estaba en el horno, hay que avisar al maestro de que saque ese pedido, porque no hay que seguir cocinando. Sacar este pedido de la cocina puede implicar seleccionar un nuevo pedido a cocinar segun la politica vigente. De manera similar, una cancelación de un pedido que se esta preparando requiere avisar al maestro de la cancelación, para pedirle el stock reutilizable, asi como también buscar un nuevo pedido a preparar. Por esta razón, nos parece acertado que aquellos que pueden llegar a tener que efectuar acciones particulares debido a una cancelación, sean invocados por el pedido cuando es cancelado. Notemos que este acercamiento es considerablemente extensible, ya que si se pretende por ejemplo agregar un nuevo controlador, solo debe implementar el método cancelar y asegurarse de que aquellos pedidos que quedan bajo su control lo tienen a el como responsable de cancelarlo.

Ademas de esta manera de resolver el problema consideramos otras formas que no fueron aplicadas. En primer lugar, pensamos en que el pedido de cancelación ingresar por el coordinador de pedidos, el cual va propagando el llamado a todos los agentes a los que tiene acceso, para que estos se fijen si les corresponde cancelar o no. Esto tiene como principal problema que se realiza un cantidad de llamadas innecesarias, pero como caracteristica positiva tiene que es bastante distribuida, ya que si bien el llamado entra por el coordinador, las invocaciones a cancelar se propagan a todos los posibles agentes.

Otra alternativa era considerar una clase canceladora que se encargue de rastrear el pedido, y luego decirle al controlador que lo estaba manejando en ese momento que lo cancele. El problema de esto es que el cancelador para buscar al responsable, va a tener que utilizar por ejemplo que los pedidos en tal estado si son de tal tipo estan bajo la orbita de tal controlador. Esto no nos parecio correcto, ni extensible, por lo cual se descartó.

Veamos a continuación algunos escenarios diferentes de cancelación.

El primer escenario consiste en cancelar un pedido que estaba en la cola de ingreso. En este caso se debe sacar de dicha cola al pedido y se debe reestablecer el stock de los insumos que no se van a utilizar.
%FIXME: como hacemos para subir el stock?
%TODO: diagramas de secuencia

En segundo lugar podemos considerar que ocurre cuando se cancela un pedido que esta en preparación. En este caso puede ocurrir que el pedido se estaba preparando en el momento de su cancelación, por lo que debe indicarse que se detenga la preparación y que se indiquen que insumos se pueden salvar.
Veremos entonces que ocurre en estos casos, mostran en el primer escenario como se cancela un pedido de solo empanadas que estaba siendo preparado, suponiendo que luego se puede empezar a preparar otro pedido que estaba en espera.
Luego modelaremos el escenario en el que se cancela un pedido que tenía su subpedido de pizzas preparado y su subpedido de empanadas sin preparar.
%FIXME: como hacemos para subir el stock?
%TODO: diagramas de secuencia

Otros lugar donde la cancelación es mas conflictiva es durante la coccion de un pedido, si el mismo estaba en la cola el proceso es simple porque solo hay que sacarlo de la misma. Ahora si el pedido estaba en el horno o estaba a medio cocinar hay que avisar al maestro para que deje de cocinar el pedido.

Finalmente la cancelación también puede darse en el ambito del controlador de entregas y del controlador de listos, en estos casos el manejo es simple, sin embargo, por ejemplo en el controlador de entregas, si la operatoria no fuera de contingencia podria requerir de una logica mas compleja de aviso al delivery.
%FIXME: entonces deberia ser una clase abstracta
\section{Clase Pedido}
\textcolor{Red}{TODO: explicacion de la clase pedido y las clases que lo heredan}

\section{Diagrama de clases}
\begin{landscape}
\begin{figure}[H]
\centering
\includegraphics[height=18cm]{./figuras/clases.png}
\end{figure}
\end{landscape}
%
%\section{Explicación de las clases}
%\clase
%{ABMproductos}
%{Esta clase se encarga de realizar las altas, bajas y modificaciones de los productos}
%{}{}
%
%\clase
%{ABMstock}
%{Esta clase se encarga de realizar las altas, bajas y modificaciones de los insumos}
%{}{}
%
%\clase
%{Agil}
%{Especialización de gestor de horno, permite aplicar la politica agil}
%{}{}
%
%\clase
%{Aviso}
%{Clase utilizada para realizar el \textit{callback} desde el gestor de horno hacia el despachador de preparación, es la encargada de ejecutar el metodo del despachador que lo notifica de que se termino de preparar algo. Esta clase permite que el despachador no necesite saber quien le avisa, y por lo tanto permite que los preparadores no requieran de metodos diferenciados para avisar que se terminaron de preparar las pizzas, o las empanadas}
%{}{}
%
%\clase{Cliente}
%{Esta clase representa a un cliente, conteniendo todos los datos del mismo.}
%{}{}
%
%\clase{ColaListos} %FIXME: nombre poco feliz
%{Esta clase contiene a los pedidos que ya estan listos. Su responsabilidad es la de conocer a todos los que estan en este estado, a fin de que despachar un pedido se haga desde esta clase}
%{}{}
%
%\clase
%{ControladorDeIngreso}
%{Controla la cola de ingreso, la cual puede ser modificada por el encargado de pedidos. Cuando algun preparador queda libre, envia el proximo pedido a preparar}
%{}{}
%
%\clase
%{ControladorCliente}
%{El controlador de cliente tiene por responsabilidad encargarse de autentificar un usuario}
%{}{}
%
%\clase
%{ControladorStock}
%{El controlador de stock, tiene por responsabilidad chequear la disponibilidad de insumos al momento de un ingreso, asi como la de hacer el decremento del stock al ingresar un pedido, generando el aviso de stock critico en caso de ser necesario.}
%{}{}
%
%\clase
%{CoordinadorDePedidos}
%{El coordinador de pedidos se encarga de controlar el ingreso de pedidos, y su ciclo de vida fuera de la cocina}
%{}{}
%
%\clase
%{DespachadorDePreparación}
%{Esta clase tiene por responsabilidad manejar la cola de pedidos que se estan preparando, recordemos que puede existir una cola de preparaci'on si hay pedidos mixtos a la espera de uno de los maestros. El controlador de ingresos distribuye los pedidos a los distintos preparadores y despacha cada pedido a su gestor de horno correspondiente cuando ya esta preparado.}
%{}{}
%
%\clase
%{EstimadorDeTiempos}
%{El estimador de tiempos, como lo dice su nombre, se encarga de estimar el tiempo de preparacion y cocción de un pedido}
%{}{}
%
%\clase
%{GeneradorDePedidos}
%{Esta clase se encarga de crear pedidos, creando pedidos de solo bebidas o con comida segun los productos}%FIXME: justificacion
%{}{}
%
%\clase
%{GestorHorno}
%{Clase abstracta que permite implementar diferentes politicas para el manejo del horno}
%{}{}
%
%\clase
%{Insumo}
%{Contiene la información de los distintos insumos de la pizzería}
%{}{}
%
%\clase
%{Normal}
%{Permite implementar la politica normal de manejo del horno}
%{}{}
%
%\clase
%{Pedido}
%{Contiene la información de cada pedido}
%{}{}
%
