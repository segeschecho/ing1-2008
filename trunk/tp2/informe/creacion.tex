%FIXME: ver diagrmas porq gonza cambio el dc
\section{Creación y registro de pedidos}
En este componente se agrupan las clases que entran en juego al momento 
de registrar y crear un nuevo pedido. Consideramos como parte de este
componente a la clase \textit{Pedido} propiamente dicha ya que este
componente es quien se encarga de construir sus instancias. A continuación
se detalla el diseño de cada uno de los componentes.

Este componente acopla con el componente de gestión de stock y con el de
gestión de clientes, puesto que es necesario que el ingreso de un pedido
implique modificaciones de stock, y que los pedidos se asignen a los clientes
correspondientes.

\subsection{Clase Pedido}

La clase Pedido consta de una estructura simple. Contiene, además de los datos
sobre los items que componen al pedido, información sobre el cliente que lo realizó
y otra metainformación como el horario de ingreso o la modalidad que se utilizó
para realizar el pedido (por teléfono, en el local, etc).

Dicha modalidad no se almacena como un atributo sino que se indica mediante
la herencia de subclases de Pedido. La jerarquía de herencia, que puede apreciarse
en el diagrama, no es casual sino que responde a la necesidad de tratar de forma
diferenciada los diferentes tipos de pedido. Por ejemplo, los pedidos locales no 
deben ser entregados a domicilio, y únicamente los pedidos que fueron hechos desde
una mesa tienen dicha información.

\begin{figure}[H]
\centering
\includegraphics[height=8cm]{./figuras/pedidos.png}
\caption{Herencia de pedidos}
\end{figure}

La razón por la que no se utilizó un atributo es para servirnos del patrón \textit{Visitor}
cuando es necesario implementar funcionalidad particular a solo un tipo de pedido. Si bien
hubiera sido posible utilizar implementaciones con condicionales que discriminen uno u otro
tipo de pedido, esto viola OCP y por lo tanto decidimos evitarlo.

Cabe destacar que la herencia propuesta respeta LSP puesto que la discriminación en
subclases se hace principalmente por motivos funcionales. La única operación que se
especializa es la correspondiente a la asignación de mesas, pero el resto de las
cualidades de la clase padre se mantienen intactas en todas sus subclases.

La clase Pedido contiene un atributo Horno que lo relaciona con uno de los
Hornos de la cocina. Esto constituye una clara violación de OCP, puesto que
la relación arbitraria de un pedido con un Horno no es universal sino que más
bien es propia a la política actual de asignación de hornos. Sin embargo, optamos
por realizarlo así para evitar añadir mucha complejidad al sistema.

\subsection{Otros miembros}

Ahora bien, para disponer de instancias de Pedido diferenciadas en clase, es necesario
que se tome la decisión en algún punto de cual será la clase para un cierto pedido. Para
esto nos valemos del patrón \textit{Factory}, implementado por la interfaz GeneradorDePedidos,
que produce instancias de la clase apropiada a partir de la información de un pedido. Inevitablemente
el código del \textit{Factory} viola OCP, pero lo hacemos de esta manera para luego evitar
discriminar por tipo en el resto del sistema, lo cual sería peor. Agregamos una implementación
de dicha interfaz, GeneradorDePedidosStandard, que se ocupa de la operatoria definida al momento
de realizar el diseño, y genera únicamente instancias de las subclases de Pedido definidas hasta 
el momento. Sin embargo, es fácil implementar un nuevo generador de pedidos que respete la interfaz
y soporte nuevos tipos de pedido.


La clase GeneradorDePedidos sirve de punto de entrada a este componente. La misma
posee el método generarPedido, que es invocado por el Coordinador de Pedidos, a fin de que se 
ingrese al sistema un nuevo pedido. El Generador se encarga de llamar al ControladorDeStock para 
que verifique que el stock existente sea capaz de satisfacer al pedido. Además, el generador indica
al controlador que realice el decremento del stock. Este a su vez podría notificar a la GUI si el stock
quedara por debajo de niveles críticos.

A continuación, el generador se encarga de llamar al EstimadorDeTiempos. Esta clase es abstracta, ya que 
pensamos que como la pizzería desea ir refinando estas estimaciones, es probable que la forma de estimar 
se modifique de forma periódica. Esto corresponde al patrón \textit{Strategy}. La estimación desarrollada 
en \ref{modifEstim} es implementada por la clase EstimadorBasico. Es de esperarse que estrategias de estimación
más sofisticadas induzcan más acomplamiento para lograr mayor precisión, pero esto es inevitable.

El Asignador de hornos es el que decide en qué horno ubicar al pedido. 
La asignación especificada en el TP 1 es realizada por el el Asignador Standard. 
El criterio a seguir es que los pedidos simples tienen su horno por defecto, mientras que 
para los pedidos mixtos se debe preguntar al encargado qué horno se asigna. La clase Asignador 
de Horno es abstracta porque potencialmente se podría modifcar la forma de asignar con el fin 
de balancear la carga, lograr un tiempo de demora ponderada menor o establecer prioridades, 
entre otras cosas.

Finalmente, el Calculador de Precios se encarga de obtener el precio a cobrar por el pedido. Nuevamente,
se implementó una interfaz genérica para permitir cambiar la implementación. Implementaciones más
sofisticadas podrían permitir realizar promociones si se compran determinados subconjuntos de productos,
o asignar descuentos a clientes preferenciales.

\subsection{Modelado de escenarios}

\subsubsection{Creación de un pedido}
\label{creacionPed}
Cuando el coordinador de pedidos recibe la orden de crear un nuevo pedido, la deriva al generador 
de pedidos. Este se encargará de devolverle un pedido nuevo. El generador de pedidos invoca al 
controlador del stock, para que verifique la factibilidad de ingresar el pedido. En caso de no 
ser posible, el generador producirá una excepción que será propagada para poder mostrar qué 
producto no pudo ser ordenado.

En este escenario modelaremos el proceso de creación de una forma general (usando como ejemplo
un pedido de mostrador) para luego mostrar escenarios particulares que pueden ocurrir durante 
este proceso.

En primer lugar, el generador invoca al controlador de stock para que realice el chequeo y 
en caso de ser posible decremente el stock. Luego, se genera un ID para el pedido y se crea
la instancia con el tipo correspondiente. Una vez creado el pedido, este pasa al asignador de 
horno que establece que horno le corresponde al pedido (en caso de que corresponda). Luego se procede 
a realizar la estimación de tiempos de cocción y el cálculo del precio. Finalmente, el pedido queda ingresado
y se delega al resto del sistema.
El generador standard genera el ID de una forma trivial, recuerda el ultimo ID que asignó en un atributo, y cuando debe crear un nuevo ID toma el siguiente y modifica su atributo.

El diagrama de secuencias es el siguiente:

\begin{landscape}
\begin{figure}[H]
\centering
\includegraphics[height=10cm]{./figuras/crearMostrador.png}
\caption{Creación de un nuevo pedido}
\end{figure}
\end{landscape}

Este escenario es el que se dispara cuando en el ingreso de pedidos el coordinador de pedidos le pide al generador de pedidos que cree un nuevo pedido.
\subsubsection{Estimación de tiempos}
Dentro de la especificación dada, uno de los requerimientos era estimar el tiempo de salida de un pedido. Como mencionamos en \ref{modifEstim} decidimos cambiar el algoritmo de estimación, por otro que esperamos sea un poco mas preciso. El pseudocodigo de dicho algoritmo es el siguiente:

\begin{algorithm}[H]
\caption{Estima el tiempo de terminacion de un pedido}
\begin{algorithmic}[1]
\PARAMS{p:Pedido cuyo tiempo se desea estimar}
\STATE listaPedidos = Pedido.allInstances()
\STATE tiempoCoccionPizzas = 0
\STATE tiempoCoccionEmpanadas = 0
\STATE tiempoPreparacion = 0
\FOR{cada pedido en lista}
\STATE\COMMENT{notar que en la lista esta también el mismo p}
\IF{el pedido esta en un estado anterior a preparado}
\FOR{cada producto del pedido}
\STATE tiempoPreparacion += tiempo de preparacion del producto
\ENDFOR
\FOR{cada producto del pedido}
\IF{El producto es una pizza}
\STATE tiempoCoccionPizzas += tiempo de cocción del producto
\ENDIF
\IF{El producto es una empanada}
\STATE tiempoCoccionEmpanadas += tiempo de cocción del producto
\ENDIF
\ENDFOR
\ELSE\IF{el pedido esta en la cola del mismo horno que p y su estado es preparado o al horno}
\FOR{cada producto del pedido}
\IF{El producto es una pizza}
\STATE tiempoCoccionPizzas += tiempo de cocción del producto
\ENDIF
\IF{El producto es una empanada}
\STATE tiempoCoccionEmpanadas += tiempo de cocción del producto
\ENDIF
\ENDFOR
\ENDIF
\ENDIF
\ENDFOR
\STATE tiempo de coccion = $\frac{ \frac{tiempoCoccionPizzas}{ pizzas por modulo del horno de p} + \frac{tiempoCoccionEmpanadas}{empanadas por modulo del horno de p}}{cantidad de modulos del horno de p}$
\STATE p.tiempoEstimado = tiempo de coccion + tiempoPreparacion
\end{algorithmic}
\end{algorithm}

Llamamos estimador basico a la clase que implementa este algoritmo de estimación.

Veamos ahora algunos escenarios relacionados con dicha estimación:

Al producirse la llamada lo que va a hacer el estimador basico es recorrer todos los productos, para conseguir sus tiempos de coción y de preparacióon. La forma en la que lo logra, decidimos que sea mostrada en otro diagrama, ya que sino obtendriamos un diagrama nada claro. Una vez que estimo esos tiempos, obtiene los tamaños de los modulos y la cantidad de modulos del horno y realiza el calculo descripto en el pseudocodigo.

\begin{figure}[H]
\centering
\includegraphics[height=11cm]{./figuras/estimadorDeTiempos.png}
\caption{Estimación de tiempos}
\end{figure}

A continuación veremos como obtiene las estimaciones de los tiempos. Es basicamente recorrer los productos chequeando su estado y su tipo, por lo cual creemos que no es necesario realizar mayores explicaciones:

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{./figuras/EstimarTiempoDePreparacion.png}
\caption{Estimación de tiempos de preparación}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{./figuras/EstimarTiempoDeCoccionEmpanadas.png}
\caption{Estimación de tiempo de cocción para las empanadas}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[height=9cm]{./figuras/EstimarTiempoDeCoccionPizzas.png}
\caption{Estimación de tiempo de cocción para las pizzas}
\end{figure}

\subsubsection{Verificación de stock}
Ver apartado correspondiente en \label{cosasDeStock}.


\subsubsection{Asignación de horno}
Una parte del proceso de creado de un pedido es la asignación del horno. A partir de la especificación dada en el trabajo anterior, la selección del horno es automatica en los casos donde el encargado de pedidos no participa, y es manual en los casos donde el encargado si participa y el pedido que se ingresa es mixto. Dado que estamos modelando la operatoria de contingencia, resulta que todos los pedidos pasan por el encargado de pedidos, de modo que en estos casos solo se realiza asignación automatica cuando el pedido es solo de empanadas o solo de pizzas.

El asignador de hornos standar permite realizar esta asignación, lo que va a hacer con su metodo asignarHorno es recorrer los productos del pedido buscando si hay empanadas y pizzas (utiliza atributos del tipo TipoProducto para eso). Si hay de ambos, se dispara un notify, el cual no es el notify void del patron observer, ya que esta vez se queda esperando el horno que recibe. La GUI tienen que conocer al horno para poder mostrarlo. En caso de que no sea mixto asigna el horno correspondiente, y si solo hay bebidas, deja el atributo horno del pedido en NULL.

Notemos que utilizar pizza y empanada para separar no es muy extensible, sin embargo el criterio de asignación de horno toma esta decisión ad hoc de una manera inflexible. Potencialmente podrían hacerse otras formas de asignar, por ejemplo usando algo de teoria de colas, para decidir donde es conveniente encolarlo para lograr un tiempo promedio de salida menor. El modelo permite esto mediante la extensión de la clase asignadorDeHorno y la implementación del metodo asignar horno.

Veamos como es el escenario que dispara la llamada a asignarHorno en un asignardor standard: 
\begin{figure}[H]
\centering
\includegraphics[height=14cm]{./figuras/AsignadorDeHornoStandard.png}
\caption{Asignación de horno}
\end{figure}

\subsubsection{Calculo de precio}
El calculo del precio es sencillo, se recorren los productos y se suman sus precios unitarios. Potencialmente la clase calculadorDePrecios podria extenderse para soportar por ejemplo promociones de modo que segun la composición del pedido el calculo de los precios varie.

Como dijimos el procedimiento es sencillo, creemos que no vale la pena detallarlo mas. El diagrama de secuencias resultante es el siguiente:

\begin{figure}[H]
\centering
\includegraphics[height=9cm]{./figuras/calculadorDePrecios.png}
\caption{Calculo de precio de un pedido}
\end{figure}

